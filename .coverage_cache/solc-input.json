{
  "language": "Solidity",
  "sources": {
    ".coverage_contracts/EternalStorage.sol": {
      "content": "pragma solidity 0.6.6;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./lib/StorageHelper.sol\";\r\nimport \"./InsurancePool.sol\";\r\n\r\n\r\n/// @author PanDAO - https://pandao.org\r\n/// @title  Implementation of Eternal Storage(https://fravoll.github.io/solidity-patterns/eternal_storage.html)\r\n/// @notice This contract is used for storing contract network data\r\n/// @dev PanDAO network contracts can read/write from this contract\r\ncontract EternalStorage {\nfunction coverage_0xcf343fca(bytes32 c__0xcf343fca) public pure {}\n\r\n  struct InsurancePoolQueuePosition {\r\n    address liquidityProviderAddress;\r\n    uint256 amount;\r\n  }\r\n\r\n  struct Storage {\r\n    mapping(bytes32 => uint256) uIntStorage;\r\n    mapping(bytes32 => string) stringStorage;\r\n    mapping(bytes32 => address) addressStorage;\r\n    mapping(bytes32 => bool) boolStorage;\r\n    mapping(bytes32 => int256) intStorage;\r\n    mapping(bytes32 => bytes) bytesStorage;\r\n    mapping(address => InsurancePoolQueuePosition[]) insurancePoolQueueStorage;\r\n  }\r\n\r\n  Storage internal s;\r\n\r\n  //////////////////////////////\r\n  /// @notice Modifiers\r\n  /////////////////////////////\r\n  modifier onlyCurrentImplementation() {coverage_0xcf343fca(0x9e80bf191960f648d1dde458e43db41c434d84cbab92f1e46009c3c7e6b5eac3); /* function */ \n\r\ncoverage_0xcf343fca(0x7acba45751316cd39ce541acdecb0268c53262432f00f189d2e11fdafa53f698); /* line */ \n    _;\r\n  }\r\n\r\n  //////////////////////////////\r\n  /// @notice Getter Functions\r\n  /////////////////////////////\r\n\r\n  /// @notice Get stored contract data in uint256 format\r\n  /// @param _key bytes32 location should be keccak256 and abi.encodePacked\r\n  /// @return uint256 _value from storage _key location\r\n  function getUint(bytes32 _key) external view returns (uint256) {coverage_0xcf343fca(0x3d4038b503ef09f4633a00d890157ea60cb1803448e5730b1ae8d5ea0b509ca0); /* function */ \n\r\ncoverage_0xcf343fca(0x95268541afd5483cd3d8c5ef66d021db714391ccc7070ed249cb4f164c7f9c46); /* line */ \n    coverage_0xcf343fca(0xbc1f056a58133ad8309d6c093478a8ad4e06c438489e73f95c3875aa6c7a0055); /* statement */ \nreturn s.uIntStorage[_key];\r\n  }\r\n\r\n  /// @notice Get stored contract data in string format\r\n  /// @param _key bytes32 location should be keccak256 and abi.encodePacked\r\n  /// @return string _value from storage _key location\r\n  function getString(bytes32 _key) external view returns (string memory) {coverage_0xcf343fca(0x2aaa9bbc16a741b165ceccdd5f636b7a7632cd15c4c5dd7321823827dbec1be6); /* function */ \n\r\ncoverage_0xcf343fca(0x628593b5f1dfd9239139c7d43028a88f60f75e79b7bd0ad016a60f9e5b01035a); /* line */ \n    coverage_0xcf343fca(0xaaf92a2a245ddbb2595942811bd9eb947e7f8b9c5ad49a87f5873a8e88950e9f); /* assertPre */ \ncoverage_0xcf343fca(0xcd76fce4bb23f59671ee364314eb5c05e02a18e8260696018e1cb24828253ac1); /* statement */ \nrequire(_key[0] != 0);coverage_0xcf343fca(0xe3de47a28689bdd1e292ce322f00ba8839863afea59ffda3d013de1697b88934); /* assertPost */ \n\r\n\r\ncoverage_0xcf343fca(0xa29f11f5121b6cc02e38dec6f70488b2bc3ac94211f7ca311ff4ef3420b3abe3); /* line */ \n    coverage_0xcf343fca(0x35a203873783ba26d1477031aa10b35f14e3390e4220ea9a6e6df507f2ba60fd); /* statement */ \nreturn s.stringStorage[_key];\r\n  }\r\n\r\n  /// @notice Get stored contract data in address format\r\n  /// @param _key bytes32 location should be keccak256 and abi.encodePacked\r\n  /// @return address _value from storage _key location\r\n  function getAddress(bytes32 _key) external view returns (address) {coverage_0xcf343fca(0x61abca2cf5fa4acbd1704e67b717b27e57f90cbdd59d58714c8d269c41b3ad7c); /* function */ \n\r\ncoverage_0xcf343fca(0x82d40a5e863c628dc93a51cab89eac0b3f845b8e0e0679f3fa13c75259553cea); /* line */ \n    coverage_0xcf343fca(0xc1d83eb7357b276a288272f90e75987d5745a0e1275c274381fa304300b06e74); /* statement */ \nreturn s.addressStorage[_key];\r\n  }\r\n\r\n  /// @notice Get stored contract data in bool format\r\n  /// @param _key bytes32 location should be keccak256 and abi.encodePacked\r\n  /// @return bool _value from storage _key location\r\n  function getBool(bytes32 _key) external view returns (bool) {coverage_0xcf343fca(0xa98db38e106f046a9e5368af0812082ca8ff7cae8f78ad74bcb9a638ec8bf3e0); /* function */ \n\r\ncoverage_0xcf343fca(0x13ee7761327663823bd4f7bb2b3a108ebe7944f7a535a762eefd6abbb294160b); /* line */ \n    coverage_0xcf343fca(0xad889dbdd8192efa8733620dbfe6cf638e07d91b8769136b3cd3a26f5dc72fee); /* statement */ \nreturn s.boolStorage[_key];\r\n  }\r\n\r\n  /// @notice Get stored contract data in int256 format\r\n  /// @param _key bytes32 location should be keccak256 and abi.encodePacked\r\n  /// @return int256 _value from storage _key location\r\n  function getInt(bytes32 _key) external view returns (int256) {coverage_0xcf343fca(0xde41c3755cdd05ae65ff60597ca4d4da9af19e3988206fab5a804ea78e804650); /* function */ \n\r\ncoverage_0xcf343fca(0x72a0d7f7d10ada88d015728844afb876663f73afd402db67cfb4fb341c763818); /* line */ \n    coverage_0xcf343fca(0x9e72cdae3a6c229ec68ac3ec866440123f8d6623c9364560c402f6e2ce935524); /* statement */ \nreturn s.intStorage[_key];\r\n  }\r\n\r\n  /// @notice Get stored contract data in bytes format\r\n  /// @param _key bytes32 location should be keccak256 and abi.encodePacked\r\n  /// @return bytes _value from storage _key location\r\n  function getBytes(bytes32 _key) external view returns (bytes memory) {coverage_0xcf343fca(0xe855c8ec29ab571969860f36f1d7c9ef4ffc9a835e9a7288c1d9f38bfe948246); /* function */ \n\r\ncoverage_0xcf343fca(0x29d147be64ee5a7d544cff3b3aec484e658de9874e79c877979ab27b461e2414); /* line */ \n    coverage_0xcf343fca(0xc1680a9c00fae5e9bb553f350291f98d87ab37b236c49891c17df754f13ff38d); /* assertPre */ \ncoverage_0xcf343fca(0x88573b5bc6cb695cea50cf0a1c6323a9ef8d8b94373719d869e36af441e65cf9); /* statement */ \nrequire(_key[0] != 0);coverage_0xcf343fca(0xc7dc0bcfc40de3b25cc3de4d7d1e87acb17887f1d4c2271d900f6a3627cd9a2f); /* assertPost */ \n\r\n\r\ncoverage_0xcf343fca(0x419c6fe73aa178967c4ccaeca191125c00f2f4ff75fe8ca340bb12fcafa77bdd); /* line */ \n    coverage_0xcf343fca(0xb4d1747d0a4e42c6461b68e9bcda4bc5c2ba4a945c0eeb5f4225b31f02e5d939); /* statement */ \nreturn s.bytesStorage[_key];\r\n  }\r\n\r\n  /// @notice Returns index of InsurancePoolQueuePositions by Liquidity Provider Address\r\n  /// @param _insuredTokenAddress Address for the token that is insured\r\n  /// @param _liquidityProviderAddress Address for the liquidity provider\r\n  /// @return InsurancePoolQueuePosition[] Array of InsurancePoolQueuePosition Structs for the given liquidity provider address\r\n  function getInsurancePoolQueuePositions(\r\n    address _insuredTokenAddress,\r\n    address _liquidityProviderAddress\r\n  ) external view returns (InsurancePoolQueuePosition[] memory) {coverage_0xcf343fca(0x97d1d012c0e99e457ccd81781fc6254e0691830af141426779d9370b859a072a); /* function */ \n\r\ncoverage_0xcf343fca(0x534e35f3be12b774025e6a894604a5b794895a73e82cb69cabe699c49d8bd65f); /* line */ \n    coverage_0xcf343fca(0x12d220332e6ab14d2ac6f26256b1d54776763e0ebf2175d0acfa722eba9d5f9f); /* statement */ \nInsurancePoolQueuePosition[] memory insurancePoolQueue = s\r\n      .insurancePoolQueueStorage[_insuredTokenAddress];\r\n\r\ncoverage_0xcf343fca(0xc694c82df68584ff4eef548edefa3c5952f84248c6b06a0dd8a9ca108cb94275); /* line */ \n    coverage_0xcf343fca(0x6f66ff7596b0bec799cdb8b731ea9a146814ef438f377e67742236d4b16ff81e); /* statement */ \nInsurancePoolQueuePosition[] memory liquidityProviderPositions;\r\n\r\ncoverage_0xcf343fca(0xf782eafadca11be9b06f797952519add9d63ca88ee4862a8c4e1cd28ead90b57); /* line */ \n    coverage_0xcf343fca(0x75dcca73f14cf1ff8687bbb78e45e685d35cb1fec571d06e6e0c54e3f24d0760); /* statement */ \nfor (uint256 i = 0; insurancePoolQueue.length <= i; i++) {\r\ncoverage_0xcf343fca(0x32fd10c193b151439d658f801f6d0929f9bc3e568c6da2490058157aafe5d283); /* line */ \n      coverage_0xcf343fca(0x425efae9acf490bf0b796300d25733ce9dc23eb8a5a5e418a40751ad5157c88b); /* statement */ \nif (insurancePoolQueue[i].liquidityProviderAddress == _liquidityProviderAddress) {coverage_0xcf343fca(0x682cc6bd66979b851ccd64c11654a1a1833f45feadd5add61f64570dcfe956bb); /* branch */ \n\r\ncoverage_0xcf343fca(0x0602c6da6e45450096dc4dde2b6bf1f189f9e0a55a67e059be8c0d7c90c63753); /* line */ \n        coverage_0xcf343fca(0xb40e28169a04ecfe210daf9e233105e5a00ed2f69b7567d24ae3c73c03d245a8); /* statement */ \nliquidityProviderPositions[liquidityProviderPositions.length] = insurancePoolQueue[i];\r\n      }else { coverage_0xcf343fca(0x5f872b6a0695353fe47a7b4f3f9cf63d2d67f0bce29ac22c4fb0c3b3ed323219); /* branch */ \n}\r\n    }\r\n\r\ncoverage_0xcf343fca(0xdfde38cd6e37b68bd87c4e2cf5183c65dc1ae8ee1b66bb842dfca9d70e1bb54f); /* line */ \n    coverage_0xcf343fca(0xd37c1776af388d37608d6c7d3101c6e2cd53e512ba8aacb2ca860da5712db104); /* statement */ \nreturn liquidityProviderPositions;\r\n  }\r\n\r\n  function getInsurancePoolQueue(address _insuredTokenAddress)\r\n    external\r\n    view\r\n    returns (InsurancePoolQueuePosition[] memory)\r\n  {coverage_0xcf343fca(0x82a7f697a747c30ac33d9115a1c9cb196d4f3370fc6ed30c69b81b9fa833819e); /* function */ \n\r\ncoverage_0xcf343fca(0xe69c50e911d90c4459dd427ec19b05e76c2e98472eadc288abe3e44bc1d7f600); /* line */ \n    coverage_0xcf343fca(0xde98e3e2d4bb447f6b88d1ddd73e5fcd7d3f63f106fc09969e4887e1f8e0ffc4); /* statement */ \nInsurancePoolQueuePosition[] memory insurancePoolQueue = s\r\n      .insurancePoolQueueStorage[_insuredTokenAddress];\r\n\r\ncoverage_0xcf343fca(0xd2736a8861d709db6970e52dfbd2eb3fa93331b496f2a4d13a8ebd78a15e27b4); /* line */ \n    coverage_0xcf343fca(0x7aecf935979a3baabc30221fa8d33233da6baf2a0fb732b41f2abcf9cf6befd9); /* statement */ \nreturn insurancePoolQueue;\r\n  }\r\n\r\n  //////////////////////////////\r\n  /// @notice Setter Functions\r\n  /////////////////////////////\r\n\r\n  /// @notice Store contract data in uint256 format\r\n  /// @dev restricted to latest PanDAO Networks contracts\r\n  /// @param _key bytes32 location should be keccak256 and abi.encodePacked\r\n  /// @param _value uint256 value\r\n  function setUint(bytes32 _key, uint256 _value) external {coverage_0xcf343fca(0xaa5407459013e075af39042428a22e61822fd2ecf6d6276e578babbc0d6cd028); /* function */ \n\r\ncoverage_0xcf343fca(0x1930528589e8b7ca3dace94ef316556c01832a4e3b478212d2cab134ab424a76); /* line */ \n    coverage_0xcf343fca(0x8da3140c7d14f9d9be69cbb9e2c1edf7373a726e14e3c9ce6404d70eec288d5f); /* statement */ \ns.uIntStorage[_key] = _value;\r\n  }\r\n\r\n  /// @notice Store contract data in string format\r\n  /// @dev restricted to latest PanDAO Networks contracts\r\n  /// @param _key bytes32 location should be keccak256 and abi.encodePacked\r\n  /// @param _value string value\r\n  function setString(bytes32 _key, string calldata _value) external {coverage_0xcf343fca(0x77d4b7f8e0dade344bb8ff8ff1fd58626c5d0bb86574db89234b27716b248470); /* function */ \n\r\ncoverage_0xcf343fca(0x6320d3b58ff19e5d171330422ef3af07dbe1d734ebc0687c1361d5bdad3168fd); /* line */ \n    coverage_0xcf343fca(0xa316fab9e8b5f0d7c66bffa67e6bf6d5acdb41daf410f005019c0430bf9c6ade); /* statement */ \ns.stringStorage[_key] = _value;\r\n  }\r\n\r\n  /// @notice Store contract data in address format\r\n  /// @dev restricted to latest PanDAO Networks contracts\r\n  /// @param _key bytes32 location should be keccak256 and abi.encodePacked\r\n  /// @param _value address value\r\n  function setAddress(bytes32 _key, address _value) external {coverage_0xcf343fca(0x673fc54dbcbab3ba3e15684e8dc319170cf0877c5fb57b00699fc7d929fad487); /* function */ \n\r\ncoverage_0xcf343fca(0xb43a0fb7618bb49a88bb3076df9e5870b6d5fc07a7fc2e0ee2cc3b3cd8bd58ab); /* line */ \n    coverage_0xcf343fca(0xa818821da8888a9fda372bb9f894594cae09bd7aeddd98d29e27a193cc805d47); /* statement */ \ns.addressStorage[_key] = _value;\r\n  }\r\n\r\n  /// @notice Store contract data in bool format\r\n  /// @dev restricted to latest PanDAO Networks contracts\r\n  /// @param _key bytes32 location should be keccak256 and abi.encodePacked\r\n  /// @param _value bool value\r\n  function setBool(bytes32 _key, bool _value) external {coverage_0xcf343fca(0xfba254ea27ca07b21e7ab0fb7f401294f804a2dbd4d3b150b010fdc4e934b21f); /* function */ \n\r\ncoverage_0xcf343fca(0x703b3c17c4b3a9648b9ade481ba68749b48c352ec4baa543b992cc060e63276f); /* line */ \n    coverage_0xcf343fca(0xe8fb9c8a4179fa7ef5e6b2265c01000c4536154c7e8adea0e8bfe58840ab2aa5); /* statement */ \ns.boolStorage[_key] = _value;\r\n  }\r\n\r\n  /// @notice Store contract data in int256 format\r\n  /// @dev restricted to latest PanDAO Networks contracts\r\n  /// @param _key bytes32 location should be keccak256 and abi.encodePacked\r\n  /// @param _value int256 value\r\n  function setInt(bytes32 _key, int256 _value) external {coverage_0xcf343fca(0xb9bfbe405916d4ab3c292c5a04f42e57e5e9fb682e60516c9465d4185fe923f9); /* function */ \n\r\ncoverage_0xcf343fca(0xa02bfece2a0be99077d4fcaa29f437bbc4d97da8a3c1c708fb40335694f649b2); /* line */ \n    coverage_0xcf343fca(0xa9d9f0c53ec26f0c98d7e27cef52ff426151c691f03f3acdb23ba8992b57a323); /* statement */ \ns.intStorage[_key] = _value;\r\n  }\r\n\r\n  /// @notice Store contract data in bytes format\r\n  /// @dev restricted to latest PanDAO Networks contracts\r\n  /// @param _key bytes32 location should be keccak256 and abi.encodePacked\r\n  /// @param _value bytes value\r\n  function setBytes(bytes32 _key, bytes calldata _value) external {coverage_0xcf343fca(0x52f378ab986673a71e20cb6e0a7d3b159ba122f63c20c52c43bf924d1cede9fa); /* function */ \n\r\ncoverage_0xcf343fca(0xabdd74debf984543acb970a62c83d5083bde54998967ac6a6c10f982cdef32be); /* line */ \n    coverage_0xcf343fca(0x8efaa7ad5a4883d7b3b677c109655300be6f7d878d83bd43c0d0d8f81837b9fd); /* statement */ \ns.bytesStorage[_key] = _value;\r\n  }\r\n\r\n  /// @notice Store contract data in int256 format\r\n  /// @dev restricted to latest PanDAO Networks contracts\r\n  function setInsurancePoolQueuePosition(\r\n    address _insuredTokenAddress,\r\n    address _liquidityProviderAddress,\r\n    uint256 _amount\r\n  ) external {coverage_0xcf343fca(0x2fe76502f4a4985cf0b69f1f052bef3beb2eec63c7e790793754377cd35da462); /* function */ \n\r\ncoverage_0xcf343fca(0xaae1c7060b687a613307beeafc0d59ac5c1c55d2d70634a9f90bcbd66f28e2ca); /* line */ \n    coverage_0xcf343fca(0x7bcd7d72fea1c5c63413f883440b38c6fa9d80a468f70bfe3785de1d40a2b08d); /* statement */ \nInsurancePoolQueuePosition memory insurancePoolQueuePosition;\r\ncoverage_0xcf343fca(0xa1d95f852c33e831b79f41e5a4d9cb4411bc42ee755605abc78cd1a4d680d5f0); /* line */ \n    coverage_0xcf343fca(0x2578e170e3f02b5f53b6042876590f966dd755ba61bbcb2cb0941caed443ba8a); /* statement */ \ninsurancePoolQueuePosition.liquidityProviderAddress = _liquidityProviderAddress;\r\ncoverage_0xcf343fca(0xcafa7b4804ce9f1e59edb0a75feecaa89eb25617f6b4c680762582bb5d2dd008); /* line */ \n    coverage_0xcf343fca(0x45aabaa47c4bf036daea33c255701faba483d61cd57a5f1fa0c2e3a0153d5ecf); /* statement */ \ninsurancePoolQueuePosition.amount = _amount;\r\n\r\ncoverage_0xcf343fca(0x207a7cccdc94dffe788655219cbbf37b626908a18c493a3301d8ed0ecf742f37); /* line */ \n    coverage_0xcf343fca(0x9b9bb6784f7eb7a40b713944c5c3a8ced7aba4992b89c0156667ed4468c0b64b); /* statement */ \ns.insurancePoolQueueStorage[_insuredTokenAddress].push(insurancePoolQueuePosition);\r\n  }\r\n\r\n  //////////////////////////////\r\n  /// @notice Delete Functions\r\n  /////////////////////////////\r\n\r\n  /// @notice Delete stored contract data in bytes format\r\n  /// @dev restricted to latest PanDAO Networks contracts\r\n  /// @param _key bytes32 location should be keccak256 and abi.encodePacked\r\n  function deleteUint(bytes32 _key) external {coverage_0xcf343fca(0x006c6b8f2216db2bdea214fa5badd79bcdfd84ba88654cd17a62789686efdba1); /* function */ \n\r\ncoverage_0xcf343fca(0xb53d53dd7584e05d00ea327bd42a1e804ea7718eb6aefdbcaca52d7d16210abd); /* line */ \n    delete s.uIntStorage[_key];\r\n  }\r\n\r\n  /// @notice Delete stored contract data in string format\r\n  /// @dev restricted to latest PanDAO Networks contracts\r\n  /// @param _key bytes32 location should be keccak256 and abi.encodePacked\r\n  function deleteString(bytes32 _key) external {coverage_0xcf343fca(0xca22a010ed0eeeadead3dac261be08e6ae2890a0acfa1e7fae8f7c1c5c6c0a4a); /* function */ \n\r\ncoverage_0xcf343fca(0x8ea82e4269ee213523bee1d20c3c036f48ee6eee2402e5d782c2c011424df015); /* line */ \n    delete s.stringStorage[_key];\r\n  }\r\n\r\n  /// @notice Delete stored contract data in address format\r\n  /// @dev restricted to latest PanDAO Networks contracts\r\n  /// @param _key bytes32 location should be keccak256 and abi.encodePacked\r\n  function deleteAddress(bytes32 _key) external {coverage_0xcf343fca(0x543d08847bb0d0e0578bbb228928f46ccdbd0905a35bf4ce06ddbc99c5e6ac42); /* function */ \n\r\ncoverage_0xcf343fca(0x699a15fc7b48d58e0965e1f3ec55d0ca5d6eeeac5a293ad3f60864f862824ae6); /* line */ \n    delete s.addressStorage[_key];\r\n  }\r\n\r\n  /// @notice Delete stored contract data in bool format\r\n  /// @dev restricted to latest PanDAO Networks contracts\r\n  /// @param _key bytes32 location should be keccak256 and abi.encodePacked\r\n  function deleteBool(bytes32 _key) external {coverage_0xcf343fca(0xef9c71eb0c5cd44211331af8961518281b6220a042c1b5308c95badf9b6b8078); /* function */ \n\r\ncoverage_0xcf343fca(0x98a3a29346345e7908cd680a213af1e7a0dede37e8f1844e24a951dcfe97d220); /* line */ \n    delete s.boolStorage[_key];\r\n  }\r\n\r\n  /// @notice Delete stored contract data in int256 format\r\n  /// @dev restricted to latest PanDAO Networks contracts\r\n  /// @param _key bytes32 location should be keccak256 and abi.encodePacked\r\n  function deleteInt(bytes32 _key) external {coverage_0xcf343fca(0xdd1c5d98b1e0eb0774c11915854ff87f9001363cc94187d2d04ef5808a67a3b2); /* function */ \n\r\ncoverage_0xcf343fca(0x29824743a9126622e1814720fbca34d3a9bb6838a75e041ec734cd25e1dba3a5); /* line */ \n    delete s.intStorage[_key];\r\n  }\r\n\r\n  /// @notice Delete stored contract data in bytes format\r\n  /// @dev restricted to latest PanDAO Networks contracts\r\n  /// @param _key bytes32 location should be keccak256 and abi.encodePacked\r\n  function deleteBytes(bytes32 _key) external {coverage_0xcf343fca(0x80b688d164169cc64ee51aea55a542107028141418b17ff250a0472b32d667d0); /* function */ \n\r\ncoverage_0xcf343fca(0xc160de587eb797a2e167710f0451a1962a95473e866f45ff86712630e28223fc); /* line */ \n    delete s.bytesStorage[_key];\r\n  }\r\n\r\n  function deletePositionFromInsurancePoolQueue(\r\n    address _insuredTokenAddress,\r\n    address _liquidityProviderAddress,\r\n    uint256 _amount\r\n  ) external view {coverage_0xcf343fca(0xd9aed671d0e61fc9c30c276e37b027b55b022879d08cb2edaf2623360549a5ab); /* function */ \n\r\ncoverage_0xcf343fca(0xf64ff00e1c2f6594cadab7e1cc417adb853f7f48bc8f581f4ab0f930a57572f2); /* line */ \n    coverage_0xcf343fca(0x8b046d7c75d61c471a1a5de935c8d7018384cd0dcf2da3faf8de0e2eda3dd0f3); /* statement */ \nInsurancePoolQueuePosition[] memory insurancePoolQueue = s\r\n      .insurancePoolQueueStorage[_insuredTokenAddress];\r\n\r\ncoverage_0xcf343fca(0x620cdfba0e0f5125b378535da7b76fcacd093f8acf29c432de3c557db5e0ae66); /* line */ \n    coverage_0xcf343fca(0x449627f52cf9acc06f1c32e9c716416c8a3539b7391cd37896ad5e7b504064c8); /* statement */ \nfor (uint256 i = 0; insurancePoolQueue.length <= i; i++) {\r\ncoverage_0xcf343fca(0x837dc85aa015de7525c16d360146ca51c8aca93abfa9c587dcbb85da748de033); /* line */ \n      coverage_0xcf343fca(0x2783543ea38e4252ad770d212c7fe45690479a596d81dd8ecbb3bfc37fa0c2cb); /* statement */ \nif (\r\n        insurancePoolQueue[i].liquidityProviderAddress == _liquidityProviderAddress &&\r\n        insurancePoolQueue[i].amount == _amount\r\n      ) {coverage_0xcf343fca(0xd474b091a69cababd445c318e0f1c35bcb44b481b70a7393633d7869df10946e); /* branch */ \n\r\ncoverage_0xcf343fca(0x0ac199c90863097c7479cd803b633c0c44827b49f7f5608407b262b33a78e700); /* line */ \n        delete insurancePoolQueue[i];\r\n      }else { coverage_0xcf343fca(0x5933001d31c2428a838d0fd9a340e99de53aca07548200ef3318ca04273afabf); /* branch */ \n}\r\n    }\r\n  }\r\n}\r\n"
    },
    ".coverage_contracts/lib/StorageHelper.sol": {
      "content": "pragma solidity ^0.6.0;\r\nimport \"../EternalStorage.sol\";\r\n\r\n\r\nlibrary StorageHelper {\nfunction coverage_0x0807d59e(bytes32 c__0x0807d59e) public pure {}\n\r\n  /// @notice Initialized a new contract in EternalStorage\r\n  /// @param _eternalStorage EternalStorage storage contract instance\r\n  /// @param _contractAddress address Contract address to be initialized\r\n  /// @param _contractOwner address Contract/Wallet address of owner(msg.sender)\r\n  /// @param _contractName string Usually the insurableTokenSymbol\r\n  function initializeInsurancePool(\r\n    EternalStorage _eternalStorage,\r\n    address _contractAddress,\r\n    address _contractOwner,\r\n    string memory _contractName\r\n  ) internal returns (bool) {coverage_0x0807d59e(0x98cb62ab9d537a36a4a59fadb8bbf6dc796b7630703c09c5f3f48ea769c568bd); /* function */ \n\r\n    /// @dev initialize contract in EternalStorage\r\ncoverage_0x0807d59e(0x74a7add805a2f811c673bc051dfa1e3dd558f423feec21a03510da2125bcb359); /* line */ \n    coverage_0x0807d59e(0xfd7a1831f94480171b9663baf8f9bd6231d5181c24cd8749ad81b6dcbbc3ed06); /* statement */ \n_eternalStorage.setAddress(formatAddress(\"contract.owner\", _contractAddress), _contractOwner);\r\ncoverage_0x0807d59e(0xd5d221451a22fe21b07bc3ff4291de92abe281488d341d772e82ee90f174ae07); /* line */ \n    coverage_0x0807d59e(0x0f7a3731c1b31224c57899ce180e7afa2d196c9006f11d28ee80e6d06b17ce1f); /* statement */ \n_eternalStorage.setAddress(\r\n      formatString(\"insurance.pool.name\", _contractName),\r\n      _contractAddress\r\n    );\r\ncoverage_0x0807d59e(0xc2ba5209ee881d740f7ef7a86a65054ca5dfd518b023a9f832f5dc63f28ce271); /* line */ \n    coverage_0x0807d59e(0x728cf2bc155da8ece717f29345aacefe538d735a5c459c3abb13d0054d671e3e); /* statement */ \n_eternalStorage.setAddress(\r\n      formatAddress(\"insurance.pool.address\", _contractAddress),\r\n      _contractAddress\r\n    );\r\n\r\ncoverage_0x0807d59e(0xfdbd983666c1131a79d3989e61168aeb7cfa9363330ea33f0f6c7ac665da398b); /* line */ \n    coverage_0x0807d59e(0x17f0ebbb8088be8f456645d3485c07c6f62faf7c4977657f795d1789a052cdc7); /* statement */ \nreturn true;\r\n  }\r\n\r\n  /// @notice Saves Insurance Pool Data to EternalStorage\r\n  /// @param _eternalStorage EternalStorage storage contract instance\r\n  /// @param _insurancePoolAddress address Insurance pool address\r\n  /// @param _collateralTokenAddress address Collateral token address\r\n  /// @param _claimsTokenAddress address Claims token address\r\n  /// @param _insuredTokenAddress address Insured token address\r\n  /// @param _insuredTokenSymbol string Token symbol\r\n  /// @param _insureeFeeRate uint256 Rate insurance buyer pays\r\n  /// @param _serviceFeeRate uint256 Rate paid to the DAO\r\n  /// @param _premiumPeriod uint256 Premium period in blocks\r\n  /// @dev insureeFeeRate - serviceFeeRate = Liquidity Provider Earnings\r\n  function saveInsurancePool(\r\n    EternalStorage _eternalStorage,\r\n    address _insurancePoolAddress,\r\n    address _collateralTokenAddress,\r\n    address _claimsTokenAddress,\r\n    address _insuredTokenAddress,\r\n    string memory _insuredTokenSymbol,\r\n    uint256 _insureeFeeRate,\r\n    uint256 _serviceFeeRate,\r\n    uint256 _premiumPeriod\r\n  ) internal {coverage_0x0807d59e(0x979775814a16056edac61e48d89155b00c1dd87d2c8cb966afb9f5b9050349a3); /* function */ \n\r\n    /// @dev Saves IPool to EternalStorage\r\ncoverage_0x0807d59e(0xb4c2a38b028f598aab7f385cad652054d580714a61ca43f4b053c4ec0c695475); /* line */ \n    coverage_0x0807d59e(0x8fe78d8ef173c645e3a211a2b276d5b21608e7de7fa545e284d0613cd7268e92); /* statement */ \n_eternalStorage.setAddress(\r\n      formatAddress(\"insurance.pool.collateralToken\", _insurancePoolAddress),\r\n      _collateralTokenAddress\r\n    );\r\ncoverage_0x0807d59e(0x1b68225f59f1c22eb9a700b908745db725411665eac3eb33ec10134339cf12c7); /* line */ \n    coverage_0x0807d59e(0x613bd2d24f6e43eb99fa5bc9950a8ba35a862f00232678c663e28a7e4c0e6e78); /* statement */ \n_eternalStorage.setAddress(\r\n      formatAddress(\"insurance.pool.claimsToken\", _insurancePoolAddress),\r\n      _claimsTokenAddress\r\n    );\r\ncoverage_0x0807d59e(0xbfba5701f2188e469e4832b21d302d82694b46f7c0997b92dbe650b197c1a902); /* line */ \n    coverage_0x0807d59e(0x42fbf3cc9fbfbc6ee78baa2a24557dc37172e2402cd5e9ba83f1e11b77f73709); /* statement */ \n_eternalStorage.setAddress(\r\n      formatAddress(\"insurance.pool.insuredToken\", _insurancePoolAddress),\r\n      _insuredTokenAddress\r\n    );\r\ncoverage_0x0807d59e(0x9fbfd35f4749f990f9d64d4b7b96dd2508c8c18f7275dcf2d2b2e717a57e6792); /* line */ \n    coverage_0x0807d59e(0xb3b4540918bda622c4acf6df8e3476e847ac61f455f3952864b3428cd1412684); /* statement */ \n_eternalStorage.setAddress(\r\n      formatAddress(\"insurance.pool.insuredToken\", _insuredTokenAddress),\r\n      _insuredTokenAddress\r\n    );\r\ncoverage_0x0807d59e(0x8725209cc44e75ac23e1ad20861936d60e38e1ccfbacffaf3a1e8b2704001a15); /* line */ \n    coverage_0x0807d59e(0x333f0e938855631a36ea88fc2fc66212c5c5181db07b1487ccd8533fdc658eac); /* statement */ \n_eternalStorage.setString(\r\n      formatAddress(\"insurance.pool.insuredTokenSymbol\", _insurancePoolAddress),\r\n      _insuredTokenSymbol\r\n    );\r\ncoverage_0x0807d59e(0x039c67f37cc11da53dbe72a4256a07248da6557da78d9d543f1ee0f83601a238); /* line */ \n    coverage_0x0807d59e(0xd2c9d1318b626265fcf7c49d2bc14d2ce69dfc6834253a23d4dcc025d8c478ba); /* statement */ \n_eternalStorage.setUint(\r\n      formatAddress(\"insurance.pool.insureeFeeRate\", _insurancePoolAddress),\r\n      _insureeFeeRate\r\n    );\r\ncoverage_0x0807d59e(0x44fae45e78f9b00fe603c1e7b2c0f92116719d31a000be44ba2dee794706dc6d); /* line */ \n    coverage_0x0807d59e(0xa9680eb4427959178381d8d568ee33cb39b8371f2f8d99a57a65d913a266e29b); /* statement */ \n_eternalStorage.setUint(\r\n      formatAddress(\"insurance.pool.serviceFeeRate\", _insurancePoolAddress),\r\n      _serviceFeeRate\r\n    );\r\ncoverage_0x0807d59e(0x1372c47c34a76de758cf0c3943f64d3f73a52bde4c4198ffe85b8f49e2b79157); /* line */ \n    coverage_0x0807d59e(0x62d24c1043896ed9af0944832bd76eadfcf4c91613f58a36f108a1f269979681); /* statement */ \n_eternalStorage.setUint(\r\n      formatAddress(\"insurance.pool.premiumPeriod\", _insurancePoolAddress),\r\n      _premiumPeriod\r\n    );\r\n  }\r\n\r\n  // Setter Format\r\n  function formatAddress(string memory _storageLocation, address _value)\r\n    internal\r\n    pure\r\n    returns (bytes32)\r\n  {coverage_0x0807d59e(0x93000be8698c82b4e46ea4a688d09b070f3b1db08845392d8868e40732b080c0); /* function */ \n\r\ncoverage_0x0807d59e(0x85896f496a9ee21609c401fd7522e1d573b0419c131765596d27402adef606f1); /* line */ \n    coverage_0x0807d59e(0xe5eca5627b372f06a8b5d98dcdab2c9a7c2e6c87960d97757922c1ec86636bc1); /* statement */ \nreturn keccak256(abi.encode(_storageLocation, _value));\r\n  }\r\n\r\n  function formatBool(string memory _storageLocation, bool _value) internal pure returns (bytes32) {coverage_0x0807d59e(0x771b5b6b9fd35ea9cd5fc243b6aef022f500086b87bfb219451946ac6198c043); /* function */ \n\r\ncoverage_0x0807d59e(0x53eea6764df008f70161ff3e19cad0a77072fd95e129ec4e8e64f539c7322ee7); /* line */ \n    coverage_0x0807d59e(0x8d06c2c4a351ae89414bfeda16bb0da170698f79657d210505120ba52a6afd53); /* statement */ \nreturn keccak256(abi.encode(_storageLocation, _value));\r\n  }\r\n\r\n  function formatInt(string memory _storageLocation, int256 _value)\r\n    internal\r\n    pure\r\n    returns (bytes32)\r\n  {coverage_0x0807d59e(0x028e5bb4f39c36cc0e6bad6b15565e47bb53ba825c5ed9970f3c2f1cb5769c18); /* function */ \n\r\ncoverage_0x0807d59e(0x6217f0f354b69653a3dc3fe48ae588b6e2933452a160b82299eef383700d01a1); /* line */ \n    coverage_0x0807d59e(0x642fff9450d5c1a721809ae7ae64ec495b8a0e867cb2863bf320cf65dd04f70d); /* statement */ \nreturn keccak256(abi.encode(_storageLocation, _value));\r\n  }\r\n\r\n  function formatString(string memory _storageLocation, string memory _value)\r\n    internal\r\n    pure\r\n    returns (bytes32)\r\n  {coverage_0x0807d59e(0x1f3cf61ef05848ea49681f2e5dbba20b467fbd7abb38e92dcecb01e9419d2bee); /* function */ \n\r\ncoverage_0x0807d59e(0xcdda782322e6e4e144f1d6332f59c800ae08f05f337c25fab99c3093546ce4c7); /* line */ \n    coverage_0x0807d59e(0x0cc27e443dc5568aa09e7421b9a38989a26012bfe493cefc4e0a093be64a8a9a); /* statement */ \nreturn keccak256(abi.encode(_storageLocation, _value));\r\n  }\r\n\r\n  function formatUint(string memory _storageLocation, uint256 _value)\r\n    internal\r\n    pure\r\n    returns (bytes32)\r\n  {coverage_0x0807d59e(0x20255375c73764e9423a5606756641bec2ca54e5d89e5249239253fcafaea497); /* function */ \n\r\ncoverage_0x0807d59e(0xd6dc1e730ff770e37c7a19107d93086a9fc00de799f913acecae93cc7ec9e2e3); /* line */ \n    coverage_0x0807d59e(0x1925880c3401475d503dd6c1aed863814e220ad9a5179e5bd16b9aabd462d296); /* statement */ \nreturn keccak256(abi.encode(_storageLocation, _value));\r\n  }\r\n\r\n  // Getter Format\r\n  function formatGet(string memory _location) internal pure returns (bytes32) {coverage_0x0807d59e(0xe81c0ae97dab5be2ec4e78909b73178136687195cce3959c337d866f97430219); /* function */ \n\r\ncoverage_0x0807d59e(0x0ae245e520958a15227e966cb2e3f06d53f122e4efcdb3c88f712c22964a061e); /* line */ \n    coverage_0x0807d59e(0x954f0c0a77c709fff856942c3fc5d38e82d43c3c3d292aae9b6af0faeba652f8); /* statement */ \nreturn keccak256(abi.encode(_location));\r\n  }\r\n}\r\n"
    },
    ".coverage_contracts/InsurancePool.sol": {
      "content": "pragma solidity 0.6.6;\r\n\r\nimport \"@nomiclabs/buidler/console.sol\";\r\n\r\nimport \"./EternalStorage.sol\";\r\nimport \"./lib/StorageHelper.sol\";\r\nimport \"./lib/StringHelper.sol\";\r\nimport \"./factories/TokenFactory.sol\";\r\nimport \"./tokens/InsuranceToken.sol\";\r\n\r\n\r\n/// @author PanDAO - https://pandao.org\r\n/// @title PanDAO Insurance Pool\r\n/// @notice PanDAO Insurance Pool is the implementation contract which allows a user to add/remove collateral, claim rewards, and create claims\r\ncontract InsurancePool {\nfunction coverage_0x1465c448(bytes32 c__0x1465c448) public pure {}\n\r\n  /// @dev Gives access to PanDAO Eternal Storage\r\n  EternalStorage internal eternalStorage;\r\n\r\n  event InsurancePoolCreated(\r\n    address insurancePoolAddress,\r\n    address insuredTokenAddress,\r\n    string insuredTokenSymbol,\r\n    uint256 insureeFeeRate,\r\n    uint256 premiumPeriod,\r\n    uint256 serviceFeeRate\r\n  );\r\n\r\n  /// @notice Stores IPool information on init\r\n  /// @param _insurableTokenAddress the digital asset to be insured\r\n  /// @param _insurableTokenSymbol the symbol for the digital asset to be insured\r\n  /// @param _insureeFeeRate The rate the insuree pays\r\n  /// @param _serviceFeeRate The DAO's cut from the insuree premium\r\n  /// @param _premiumPeriod number of blocks between premium payments\r\n  /// @param _eternalStorageAddress address contract address of eternalStorage\r\n  /// @dev _insureeFeeRate - _serviceFeeRate = insurerFee\r\n  constructor(\r\n    address _insurableTokenAddress,\r\n    string memory _insurableTokenSymbol,\r\n    uint256 _insureeFeeRate,\r\n    uint256 _serviceFeeRate,\r\n    uint256 _premiumPeriod,\r\n    address _eternalStorageAddress\r\n  ) public {coverage_0x1465c448(0x5f0706566c84e8aef72b2badd82b05956f9ce1b1399e7670b9f6ef93e5a85b5c); /* function */ \n\r\ncoverage_0x1465c448(0x90583f1e7fd735c02cc2050f770de905481be918de1ea90301eda5f5c29049e9); /* line */ \n    coverage_0x1465c448(0x0a2a67fee646e9f25f31ed60db80ea251dd526359ddd0d4c08cdce1d3b805dad); /* statement */ \neternalStorage = EternalStorage(_eternalStorageAddress);\r\n\r\ncoverage_0x1465c448(0xcf27de1d86a448a5aa674445fc5553c64ae2022b5ea351f565bf3a1f39062682); /* line */ \n    coverage_0x1465c448(0xa503733257540e68188d9f16aaf8d3a30ec564087e9027240547a8c203c27221); /* statement */ \naddress insurableToken = eternalStorage.getAddress(\r\n      StorageHelper.formatAddress(\"insurance.pool.insuredToken\", _insurableTokenAddress)\r\n    );\r\n\r\n    /// @dev Require insurable token to be unique\r\ncoverage_0x1465c448(0x09fcd78b333fde1da74a1d51d1bfc2d5d19f5e231cc06893ec683c55189826f8); /* line */ \n    coverage_0x1465c448(0xcfdd3b233ffc4a1c00b4895bca514351ee46fa36cb75afde69194255fc9041eb); /* assertPre */ \ncoverage_0x1465c448(0x03d959d1fcd273c933ffbbfaf820f58eb07f7a8ae6ac88bd404b998f3275c66a); /* statement */ \nrequire(insurableToken == address(0), \"PanDAO: Insurance Pool already exists for that asset\");coverage_0x1465c448(0xe95410c281d0170d9cb51a91484e94c6fe273012450a93fb1840d94b5ce2f4e6); /* assertPost */ \n\r\n\r\ncoverage_0x1465c448(0x166f3abc519ee2d1abf309fabdcdc75709d36cf6544f948be2925b9da0c53f4f); /* line */ \n    coverage_0x1465c448(0xeeb72319e5ad6537b0a3fc193ac3cbb6407baa8b1c9801d28c20321c3288850b); /* statement */ \nbool poolInitialized = StorageHelper.initializeInsurancePool(\r\n      eternalStorage,\r\n      address(this),\r\n      eternalStorage.getAddress(StorageHelper.formatString(\"contract.name\", \"Manager\")),\r\n      _insurableTokenSymbol\r\n    );\r\n\r\ncoverage_0x1465c448(0xfd5ab1290b8b6dede3387784892f327ada3262a6789f5627af0703d204bf45e9); /* line */ \n    coverage_0x1465c448(0x8b2f1e77c0e0903fa16daa636afa1eaf3171b5fa4d416111eaf14b343d0a654b); /* assertPre */ \ncoverage_0x1465c448(0x062f811afb7dbefb6f18de31451c981667d08e511b59f1753da3491581409201); /* statement */ \nrequire(poolInitialized == true, \"PanDAO: Failed to initialized Insurance Pool\");coverage_0x1465c448(0x7bc5ab106634133430a3962eb99065359073e01e1b7c9290f2ed579b9def0fd4); /* assertPost */ \n\r\n\r\n    /// @dev Create collateral and claims tokens for pool\r\ncoverage_0x1465c448(0xd0a66d067be0701753fb70df7e6ab7839dd65dce5d6df493d7d09232fc36faae); /* line */ \n    coverage_0x1465c448(0xc58a8d64e5b9cdf365fdc76789a0372f8ce1ace30e6dc90af273bdaf52cbdbc5); /* statement */ \nTokenFactory tokenFactory = TokenFactory(\r\n      eternalStorage.getAddress(StorageHelper.formatString(\"contract.name\", \"TokenFactory\"))\r\n    );\r\n\r\ncoverage_0x1465c448(0xb6e36f71fe709b891aa8015ae12ecbc02430182ca356ac2f8074e53f45f8d593); /* line */ \n    coverage_0x1465c448(0xc29c0080ef0df2ff66ed1bd8b7d8e4792e7be20537848ce6f77a143d6bd595d8); /* statement */ \naddress[] memory tokens = tokenFactory.createTokens(_insurableTokenSymbol, address(this));\r\n\r\ncoverage_0x1465c448(0x3f8f4de53459d4795b48f4aab7aea9ecd9b395440489dafa62d8871b8f1cabea); /* line */ \n    coverage_0x1465c448(0x1882320d2b718e4ed22dcb375bb0698bc0805df2d7c697e9ea99c0c9c36e483f); /* statement */ \nStorageHelper.saveInsurancePool(\r\n      eternalStorage,\r\n      address(this),\r\n      tokens[0],\r\n      tokens[1],\r\n      _insurableTokenAddress,\r\n      _insurableTokenSymbol,\r\n      _insureeFeeRate,\r\n      _serviceFeeRate,\r\n      _premiumPeriod\r\n    );\r\n\r\ncoverage_0x1465c448(0x6d8f84d858469d325292688ac86227be530bdae0e9c5d49bc136e31a689f18b3); /* line */ \n    coverage_0x1465c448(0xfd49184f68cea7c5d474b75e499359ea2ab2a55e2e2050f09baae9829eac4c25); /* statement */ \nemit InsurancePoolCreated(\r\n      address(this),\r\n      _insurableTokenAddress,\r\n      _insurableTokenSymbol,\r\n      _insureeFeeRate,\r\n      _premiumPeriod,\r\n      _serviceFeeRate\r\n    );\r\n  }\r\n\r\n  //////////////////////////////\r\n  /// @notice Public\r\n  /////////////////////////////\r\n\r\n  function addCollateralForMatching(address _insurerAddress, uint256 _amount) public payable {coverage_0x1465c448(0x630fe07adcc1f631f69628c6927d7133c4ef88770669063107dbf072f1b1c3d6); /* function */ \n\r\ncoverage_0x1465c448(0x40662233c2e34daade5cdb14791be5fc16e51bd8ab8aaf2807010e46fa32b7f3); /* line */ \n    coverage_0x1465c448(0x86a67e5942d196c73c1f341757930c31ece3548f44584e4e459688eb7c39bea1); /* statement */ \naddress collateralTokenAddress = eternalStorage.getAddress(\r\n      StorageHelper.formatAddress(\"insurance.pool.collateralToken\", address(this))\r\n    );\r\n\r\ncoverage_0x1465c448(0x3af1f59da27d04a9d6480e42189ed446e9272cb587e7780daf9ca3fa3bde191f); /* line */ \n    coverage_0x1465c448(0xf3690bb8230b8fd4362301bbba64d836ac6873b129672d65986ca784e0d57510); /* statement */ \nInsuranceToken collateralToken = InsuranceToken(collateralTokenAddress);\r\n\r\ncoverage_0x1465c448(0xa5ebc30f4824eece68583df00e3bf15a0c6ff91d290429d0a570cdcb8202d417); /* line */ \n    coverage_0x1465c448(0x0a381688f691ec5d2173964b62508814702a501a0a836c5b13e250238364ee9c); /* statement */ \naddress insuredTokenAddress = eternalStorage.getAddress(\r\n      StorageHelper.formatAddress(\"insurance.pool.insuredToken\", address(this))\r\n    );\r\n\r\ncoverage_0x1465c448(0x594ad122343bc70053e794e8d51fc276f8d334c83aedf4c94d283bca5cb4b2f3); /* line */ \n    coverage_0x1465c448(0x58b2d8bae673ef49db55aef873f693eb3f3722662203162a736079ec8662036b); /* statement */ \nERC20 insuredToken = ERC20(insuredTokenAddress);\r\n\r\ncoverage_0x1465c448(0x84ff3a950485d7c62c63b77438bdec8e7ac28ca3d79a35a9045f1fbf0a8c2e5f); /* line */ \n    coverage_0x1465c448(0xd91164627f4618339175c50ce1bbd42a096cf746b1336d0b57c0b8717e1001da); /* statement */ \ninsuredToken.transferFrom(_insurerAddress, address(this), _amount);\r\n\r\n    /// @dev Mint 1:1 representation of collateral stored in contract\r\ncoverage_0x1465c448(0xe535a5a6c35965feeb34ee771402d8ab097f655d83ca4cca4abbc842fa1cfccd); /* line */ \n    coverage_0x1465c448(0x171d9b47e94fc2f853e2241fca10909eefe63aecce6da7c18276a30114a7deb8); /* statement */ \ncollateralToken.mint(_insurerAddress, _amount);\r\n\r\n    /// @dev Approve the insurance pool to transfer the collateral representation tokens back\r\ncoverage_0x1465c448(0xcd72ceb65d43dd58e3141300da2f905eec42d95764f8f133735c23bc88cb8a96); /* line */ \n    coverage_0x1465c448(0x409c0762e8249accd10403209ba586903583722b0eb5043f788a372c805b0d24); /* statement */ \ncollateralToken.thirdPartyApprove(_insurerAddress, address(this), _amount);\r\n\r\ncoverage_0x1465c448(0x831b70c0b80465b2ad7dc99257f86f28ac9878e463581c974db86dda48148608); /* line */ \n    coverage_0x1465c448(0x79723d3d4756c5adb2509215bdf29c1eeabba439b58cd536006c2de31023f2dc); /* statement */ \neternalStorage.setInsurancePoolQueuePosition(insuredTokenAddress, _insurerAddress, _amount);\r\n  }\r\n\r\n  function buyInsurance() public {coverage_0x1465c448(0x0766a1128aeadd9e96d83decca68b36e633a68adf8af7f62ed6359c8fc16b4a8); /* function */ \n}\r\n\r\n  function claimRewards() public {coverage_0x1465c448(0x111e810fc58c2209973610bab0afcfb898c64c69dd542fd8d72d5b9dbc795cad); /* function */ \n}\r\n\r\n  function createInsuranceClaim() public {coverage_0x1465c448(0x495e417fbf384e10577617147ed31ac2a87d066d1a0a91459b8894e2d6ddf9df); /* function */ \n}\r\n\r\n  function removeCollateralFromMatching() public {coverage_0x1465c448(0x5e7b4d3501e5db1e0c804cf0bc67b9ce30e811f2bd79d8108ba4ee55d9c8833b); /* function */ \n}\r\n\r\n  function getCollateralBalance() public {coverage_0x1465c448(0x403ad40353dfdc8baed453c8a16f2713e61385f65cc9dbb0b2494217d8aa45fe); /* function */ \n}\r\n\r\n  function getClaimsBalance() public {coverage_0x1465c448(0x9aba2e7cb1582013837fdbe2f6206f13b3a85adbf10f5594a28c9e61aa85fb41); /* function */ \n}\r\n\r\n  //////////////////////////////\r\n  /// @notice Private\r\n  /////////////////////////////\r\n}\r\n"
    },
    "@nomiclabs/buidler/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.5.0 <0.7.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction log() internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log()\"));\n\t\tignored;\n\t}\tfunction logInt(int p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(int)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logByte(byte p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(byte)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n}\n"
    },
    ".coverage_contracts/lib/StringHelper.sol": {
      "content": "pragma solidity 0.6.6;\r\n\r\n\r\nlibrary StringHelper {\nfunction coverage_0xb33a6bd7(bytes32 c__0xb33a6bd7) public pure {}\n\r\n  function concat(string memory a, string memory b) internal pure returns (string memory) {coverage_0xb33a6bd7(0x9f848af98cca216960a19608679a24293e04fa86f0c30756230ea0218bf94670); /* function */ \n\r\ncoverage_0xb33a6bd7(0x9bddaa23b9b8bfb72f50a28a322400d20e2c898311eb47fcdb24cb160ded18ab); /* line */ \n    coverage_0xb33a6bd7(0xd4781c87065380ba1b6777268831a8a797765e9126b3f3d0bf2add676b3a9e25); /* statement */ \nreturn string(abi.encodePacked(a, b));\r\n  }\r\n}\r\n"
    },
    ".coverage_contracts/factories/TokenFactory.sol": {
      "content": "pragma solidity 0.6.6;\r\n\r\n/// Utilities\r\nimport \"@nomiclabs/buidler/console.sol\";\r\nimport \"../lib/StringHelper.sol\";\r\n\r\n/// Imports\r\nimport \"../tokens/InsuranceToken.sol\";\r\n\r\n\r\n/// @author PanDAO - https://pandao.org\r\n/// @title PanDAO Insurance Pool Token Factory\r\n/// @notice TokenFactory creates ERC20 tokens to represent a persons collateral or claim in the pool\r\ncontract TokenFactory {\nfunction coverage_0x9904d005(bytes32 c__0x9904d005) public pure {}\n\r\n  /// @dev Gives access to PanDAO Eternal Storage\r\n  address public eternalStorageAddress;\r\n\r\n  /// Events\r\n  event CollateralTokenCreated(\r\n    string _tokenName,\r\n    string _tokenSymbol,\r\n    address indexed _tokenAddress\r\n  );\r\n  event ClaimsTokenCreated(string _tokenName, string _tokenSymbol, address indexed _tokenAddress);\r\n\r\n  address[] internal tokens;\r\n\r\n  /// @dev Ensures that only active Insurance Pools can create tokens\r\n  modifier onlyPools(address _poolAddress) {coverage_0x9904d005(0x93de8cffc6fce08102b8c3351af633f2ddea23f283ad9d785556f2b98586d7de); /* function */ \n\r\ncoverage_0x9904d005(0x362c524747d6dbb89cc29c0f88fd06c448a111ed93e976dcf8d6aad8b401d377); /* line */ \n    _;\r\ncoverage_0x9904d005(0x8b1b360a599cd0ec5bc05b024ca3fcd9aef48d4f8919b0fef0d2fa7ba7189ce8); /* line */ \n    coverage_0x9904d005(0x9f063b5296e7011a5d92811d5bd0ec9691b657b75089bc57ca29c3814641bd6e); /* statement */ \nEternalStorage eternalStorage = EternalStorage(eternalStorageAddress);\r\n\r\ncoverage_0x9904d005(0x2bfbe7c1565c8e52699a5f85dd039c18c5559adacb42fd3ac771b73c38c94d8c); /* line */ \n    coverage_0x9904d005(0x1acbddb3949245860f6153fc14c6aa4aea24ead468ffe9b016836a74f096143d); /* statement */ \naddress insurancePool = eternalStorage.getAddress(\r\n      StorageHelper.formatAddress(\"insurance.pool.address\", _poolAddress)\r\n    );\r\n\r\ncoverage_0x9904d005(0x1453ed8ecdaae95f9c6d09e51bff09e658322c748dde7a5c1a3c2c1337417084); /* line */ \n    coverage_0x9904d005(0x1ec1cc4337a5db51fc76432b15485efcee53fefcbd868c6fcc9d123b44e2ca68); /* assertPre */ \ncoverage_0x9904d005(0xe2a83e2d8e8bfe2a6b295263a9baf35a1473c479086b104f07c64bd6e8fd086a); /* statement */ \nrequire(insurancePool != address(0), \"PanDAO: Only insurance pools can create new tokens\");coverage_0x9904d005(0x46eb31c9a5ef59592d8885e57f00338f6e6b8c97bb85683710e83b7f2e4c93db); /* assertPost */ \n\r\n  }\r\n\r\n  constructor(address _eternalStorageAddress) public {coverage_0x9904d005(0x05cc5ef2d62759c862ee4e309533c0b9fb3af277392811ef13d1bb9cce8c3a39); /* function */ \n\r\ncoverage_0x9904d005(0x94d34bf4a62ea36722cf0b37d113cbf5e2a37871bb47227d9211eb3ead7a6b66); /* line */ \n    coverage_0x9904d005(0x3cbc9f1abe19f8f2c32939b9d08e5de520ddcf8059c7c8b707da5b66f939f1ef); /* statement */ \neternalStorageAddress = _eternalStorageAddress;\r\n  }\r\n\r\n  //////////////////////////////\r\n  /// @notice Public\r\n  /////////////////////////////\r\n\r\n  /// @notice Create a set of Claim and Collateral Tokens for the Pool\r\n  /// @dev Returns CollateralToken in index position 0 and Claims token in index position 1\r\n  /// @param _insurableTokenSymbol string Insured token symbol\r\n  /// @return address[] Array of token addresses.\r\n  function createTokens(string memory _insurableTokenSymbol, address _insurancePoolAddress)\r\n    public\r\n    onlyPools(msg.sender)\r\n    returns (address[] memory)\r\n  {coverage_0x9904d005(0x22a89f9179792fea3fe7acd57e76869819d54066a4a009602fa5e6dd3c3f761a); /* function */ \n\r\n    /// Collateral token\r\ncoverage_0x9904d005(0x7a54f152bb8733237fa0f23ef29c6392529ae10de3a856b77080b26e5732e6e5); /* line */ \n    coverage_0x9904d005(0xd501f0bb4df08851f5030d129b10d5a451ef8060a972adefc6edd406d872109c); /* statement */ \naddress collateralToken = _createCollateralToken(_insurableTokenSymbol, _insurancePoolAddress);\r\ncoverage_0x9904d005(0xd93158bcf8d08f172897694ac75984200591934f0f7af4d4d69798016303e102); /* line */ \n    coverage_0x9904d005(0xc61e8cb8fe3b4f66338e154673d949921c4e9384a712e2db7e8443ef766d3697); /* statement */ \ntokens.push(address(collateralToken));\r\n\r\n    /// Claims token\r\ncoverage_0x9904d005(0xf3fc3fa3ad19642592401dc1956e6c4849b852402cdf6f7a29046ebf0ab30ec6); /* line */ \n    coverage_0x9904d005(0xe60fa8fc071c78c39c2017e75101635816b547af4fc97d971d9eb69b671a039c); /* statement */ \naddress claimsToken = _createClaimsToken(_insurableTokenSymbol, _insurancePoolAddress);\r\ncoverage_0x9904d005(0x0c3055b03fbe601bc12f33ed2a1e3aeaa91052a5908088debd6dc126d6da14c6); /* line */ \n    coverage_0x9904d005(0x58cdbcf41f4ac4d53000a7f63db55e15e9cd2baeae9963851e9afb2ae6e311d1); /* statement */ \ntokens.push(address(claimsToken));\r\n\r\ncoverage_0x9904d005(0x8d5f601ac74f28e268cbfaee7f50ae9b162bbe3bba3148b7ece6a910b3f82784); /* line */ \n    coverage_0x9904d005(0x45ab285fbb23404695738a579e627509c73a12ae8d05ac8c6012c77f6ab71689); /* statement */ \nreturn tokens;\r\n  }\r\n\r\n  //////////////////////////////\r\n  /// @notice Private\r\n  /////////////////////////////\r\n\r\n  /// @notice Create a claim token(mPAN)\r\n  /// @param _insurableTokenSymbol string Insured token symbol\r\n  /// @return address New token contract address\r\n  function _createClaimsToken(string memory _insurableTokenSymbol, address _insurancePoolAddress)\r\n    private\r\n    returns (address)\r\n  {coverage_0x9904d005(0x8ade4b4aaebe623560583b0b8412dcc4a2735d81e6afb2be9830c40a8141b7c2); /* function */ \n\r\ncoverage_0x9904d005(0x0288c544b31e93c2a07ed6dcd476bb600652808db2b8551c3ea3a149f9751a03); /* line */ \n    coverage_0x9904d005(0xe2029b00ca8117ee2863d33f6e69c48f5d7cbe745358e9ba10ae16988487b41d); /* statement */ \nstring memory claimsTokenName = StringHelper.concat(\r\n      \"PanDAO Claims Token - \",\r\n      _insurableTokenSymbol\r\n    );\r\n\r\ncoverage_0x9904d005(0xadaef4acba39961092c5ba1d6261064cab1117066fdf4541f1a49dfe88943c0c); /* line */ \n    coverage_0x9904d005(0x6cf1ae89cca390710f4b95471604e4478e5689ca0195ef193456e61ba8b90a09); /* statement */ \nInsuranceToken claimsToken = new InsuranceToken(\r\n      claimsTokenName,\r\n      \"mPAN\",\r\n      eternalStorageAddress,\r\n      _insurancePoolAddress\r\n    );\r\n\r\ncoverage_0x9904d005(0xd0b2e3ad99185c2ccec43db1d967432cc7207cac661daae264ce2bbeb5d07a45); /* line */ \n    coverage_0x9904d005(0x020a40599c46942e7619129d669b79e8354a73c5bdfe61efe04cea4f693bb1b4); /* statement */ \nemit ClaimsTokenCreated(claimsToken.name(), claimsToken.symbol(), address(claimsToken));\r\n\r\ncoverage_0x9904d005(0xb97093e9ba174636915a81ba23f8a13e3e5b104d752216cb2d1d557ea2602f68); /* line */ \n    coverage_0x9904d005(0x12fc0e90485046f96bd365a288886092ed0549510bf4655907829dda23f0e69e); /* statement */ \nreturn address(claimsToken);\r\n  }\r\n\r\n  /// @notice Create a collateral token(cPAN)\r\n  /// @param _insurableTokenSymbol string Insured token symbol\r\n  /// @return address New token contract address\r\n  function _createCollateralToken(\r\n    string memory _insurableTokenSymbol,\r\n    address _insurancePoolAddress\r\n  ) private returns (address) {coverage_0x9904d005(0x4ec3edef202d54c8dfe8f7c51a5f8a6b009a671c7e9c0fa2a8ac02d42bb48c35); /* function */ \n\r\ncoverage_0x9904d005(0x99c8b7ea8e087b6d13d1f3c318c63d06b6ea5a4a4fef343d8b4157c084e4f862); /* line */ \n    coverage_0x9904d005(0x49b3d57a6769e4d93fd116ff1511ca703f15cd9c045e5f9b3ffd5eb81170c391); /* statement */ \nstring memory collateralTokenName = StringHelper.concat(\r\n      \"PanDAO Collateral Token - \",\r\n      _insurableTokenSymbol\r\n    );\r\n\r\ncoverage_0x9904d005(0xdfdffba34e45ce6cd1c600673b38f66dcc98e10e115e9b5cb9097d7ac9fd4972); /* line */ \n    coverage_0x9904d005(0xb410da5becc2261f63e0a1ca83f9bf8150004a7c3e13e869734eceb886cf74a5); /* statement */ \nInsuranceToken collateralToken = new InsuranceToken(\r\n      collateralTokenName,\r\n      \"cPAN\",\r\n      eternalStorageAddress,\r\n      _insurancePoolAddress\r\n    );\r\n\r\ncoverage_0x9904d005(0xf3b5a351df637879bab615bb658dea10f0a0a401a7bcc088363e13a2899571cc); /* line */ \n    coverage_0x9904d005(0x43acba35c529b695b86d58064022b64b4281ae4373a3a1201ed668a56fe09ac0); /* statement */ \nemit CollateralTokenCreated(\r\n      collateralToken.name(),\r\n      collateralToken.symbol(),\r\n      address(collateralToken)\r\n    );\r\n\r\ncoverage_0x9904d005(0xeac2d2a14d725a3d650d5da28aea620089f0142e6165302a1e2bec8bc5d89442); /* line */ \n    coverage_0x9904d005(0x497720161029259dbc3735b23c75202272fd8b4518d6281e695ce9abaafa3bda); /* statement */ \nreturn address(collateralToken);\r\n  }\r\n}\r\n"
    },
    ".coverage_contracts/tokens/InsuranceToken.sol": {
      "content": "pragma solidity ^0.6.0;\r\n\r\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\r\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Pausable.sol\";\r\nimport \"../Manager.sol\";\r\nimport \"../lib/StorageHelper.sol\";\r\n\r\n\r\n/**\r\n * @dev {ERC20} token, including:\r\n *\r\n *  - ability for holders to burn (destroy) their tokens\r\n *  - a minter role that allows for token minting (creation)\r\n *  - a pauser role that allows to stop all token transfers\r\n *\r\n * This contract uses {AccessControl} to lock permissioned functions using the\r\n * different roles - head to its documentation for details.\r\n *\r\n * The account that deploys the contract will be granted the minter and pauser\r\n * roles, as well as the default admin role, which will let it grant both minter\r\n * and pauser roles to aother accounts\r\n */\r\ncontract InsuranceToken is Context, ERC20Burnable, ERC20Pausable, Manager {\nfunction coverage_0xb5af4d5a(bytes32 c__0xb5af4d5a) public pure {}\n\r\n  constructor(\r\n    string memory _name,\r\n    string memory _symbol,\r\n    address _eternalStorageAddress,\r\n    address _insurancePoolAddress\r\n  ) public ERC20(_name, _symbol) Manager(_eternalStorageAddress) {coverage_0xb5af4d5a(0xa1a109f18a99ed3877f4b88424bdc56d54459ef79cb1e265a68df410506cadb2); /* function */ \n\r\ncoverage_0xb5af4d5a(0x77480dc505b81a345d398552fed60f714d82cc24ab5cce3c6a4608d567d54c38); /* line */ \n    coverage_0xb5af4d5a(0x9ce2695ec406f2ff83003656c8db95b4f5f326cad8a0c72c45a8e4b2b45351f0); /* statement */ \neternalStorage.setAddress(\r\n      StorageHelper.formatAddress(\"contract.owner\", address(this)),\r\n      _insurancePoolAddress\r\n    );\r\n  }\r\n\r\n  function thirdPartyApprove(\r\n    address owner,\r\n    address spender,\r\n    uint256 amount\r\n  )\r\n    public\r\n    onlyOwner(\r\n      eternalStorage.getAddress(StorageHelper.formatAddress(\"contract.owner\", address(this))),\r\n      address(this)\r\n    )\r\n    returns (bool)\r\n  {coverage_0xb5af4d5a(0xb519baa66ce7b72e072208649815f3f03f9d1452a7206052b8be52924b09915f); /* function */ \n\r\ncoverage_0xb5af4d5a(0x7551f7dd60ef7362a82207dbe12cc7cea9260b1802a122347024e5b7661a70c4); /* line */ \n    coverage_0xb5af4d5a(0x68c8573cba255c590cf8e19e9dbf5d50177197188865d35450451922e4ee3205); /* statement */ \n_approve(owner, spender, amount);\r\ncoverage_0xb5af4d5a(0xd13c20d902f3c873572d0c95b0f89ae19a815d905f85475d54e17dc4b654a218); /* line */ \n    coverage_0xb5af4d5a(0x469720eb6dedcaf714fcf70e553d388925b2ce9fc61c59368d286eb4ffa5bf76); /* statement */ \nreturn true;\r\n  }\r\n\r\n  /**\r\n   * @dev Creates `amount` new tokens for `to`.\r\n   *\r\n   * See {ERC20-_mint}.\r\n   *\r\n   * Requirements:\r\n   *\r\n   */\r\n  function mint(address _to, uint256 _amount)\r\n    public\r\n    onlyOwner(\r\n      eternalStorage.getAddress(StorageHelper.formatAddress(\"contract.owner\", address(this))),\r\n      address(this)\r\n    )\r\n  {coverage_0xb5af4d5a(0x421043988e886c1fd6a625cbc8791d23f2a92add233bf2ee008ff2df676181b2); /* function */ \n\r\ncoverage_0xb5af4d5a(0xbe89577034cbed5dde0e4ff427611c2fe1ff6c58052e3d6e526089bc8fa120e3); /* line */ \n    coverage_0xb5af4d5a(0xb576bb253536bed863ddd7b332a76e20585706ad810edb6218d9c27537adefc9); /* statement */ \n_mint(_to, _amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Pauses all token transfers.\r\n   *\r\n   * See {ERC20Pausable} and {Pausable-_pause}.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the caller must have the `PAUSER_ROLE`.\r\n   */\r\n  function pause()\r\n    public\r\n    onlyOwner(\r\n      eternalStorage.getAddress(StorageHelper.formatAddress(\"contract.owner\", address(this))),\r\n      address(this)\r\n    )\r\n  {coverage_0xb5af4d5a(0x4ecb305ace1b44bb215fe24c68e913efbd759114ea7775f9a80b52fb6b7632df); /* function */ \n\r\ncoverage_0xb5af4d5a(0x9540637d8f2b2363e21530c59b1d221a31028f11a0a4a8cfb202451cde4f0a91); /* line */ \n    coverage_0xb5af4d5a(0xa7ba270817f828031b6e077458bf16d1d5c3edc174fb1fe88ef746a3c46df365); /* statement */ \n_pause();\r\n  }\r\n\r\n  /**\r\n   * @dev Unpauses all token transfers.\r\n   *\r\n   * See {ERC20Pausable} and {Pausable-_unpause}.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the caller must have the `PAUSER_ROLE`.\r\n   */\r\n  function unpause()\r\n    public\r\n    onlyOwner(\r\n      eternalStorage.getAddress(StorageHelper.formatAddress(\"contract.owner\", address(this))),\r\n      address(this)\r\n    )\r\n  {coverage_0xb5af4d5a(0x8792e912f3252d91a9ff95061274ae461272e946eccdf7a32724a36863c11a61); /* function */ \n\r\ncoverage_0xb5af4d5a(0x35fb0f90a5cc0664ceb07840ee62f8a0b24f007c296b33404c78f4dd1496e04b); /* line */ \n    coverage_0xb5af4d5a(0x00d074b976ce87d649f932ef7fbdd1875fb299323bbba170b251a7322ee2effe); /* statement */ \n_unpause();\r\n  }\r\n\r\n  // prettier-ignore\r\n  function _beforeTokenTransfer(address _from, address _to, uint256 _amount)\r\n        internal\r\n        override(ERC20, ERC20Pausable)\r\n    {coverage_0xb5af4d5a(0x026700aa547da3eaf74459b397a0ebc46d22a036a127ef0625b92cf4e9710e8a); /* function */ \n\r\ncoverage_0xb5af4d5a(0xe6fd9471a1fb7374b7962b2f67c043df49ac07ea67355da880903fb27be587fa); /* line */ \n        coverage_0xb5af4d5a(0xc5bf003fb1e221a504fef0d168335b7862788a6543778d8e2ff2d3e776893406); /* statement */ \nsuper._beforeTokenTransfer(_from, _to, _amount);\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../utils/EnumerableSet.sol\";\nimport \"../utils/Address.sol\";\nimport \"../GSN/Context.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using Address for address;\n\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view returns (bool) {\n        return _roles[role].members.contains(account);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\n        return _roles[role].members.length();\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n        return _roles[role].members.at(index);\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to grant\");\n\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to revoke\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (_roles[role].members.add(account)) {\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (_roles[role].members.remove(account)) {\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\n * (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint256(_at(set._inner, index)));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "pragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20MinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./ERC20.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \"ERC20: burn amount exceeds allowance\");\n\n        _approve(account, _msgSender(), decreasedAllowance);\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20Pausable.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"./ERC20.sol\";\nimport \"../../utils/Pausable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n */\nabstract contract ERC20Pausable is ERC20, Pausable {\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        require(!paused(), \"ERC20Pausable: token transfer while paused\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../GSN/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\ncontract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor () internal {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    ".coverage_contracts/Manager.sol": {
      "content": "pragma solidity 0.6.6;\r\n\r\nimport \"@nomiclabs/buidler/console.sol\";\r\nimport \"@pie-dao/proxy/contracts/PProxyPausable.sol\";\r\n\r\n// Imports\r\nimport \"./EternalStorage.sol\";\r\nimport \"./lib/StorageHelper.sol\";\r\nimport \"./lib/StringHelper.sol\";\r\nimport \"./InsurancePool.sol\";\r\n\r\n\r\n/// @author PanDAO - https://pandao.org\r\n/// @title PanDAO Contract Network Manager\r\n/// @notice This contract can be used by PanDAO to manage `InsurancePools` and resolve claims\r\n/// @dev All functionality controlled by Aragon AGENT\r\ncontract Manager {\nfunction coverage_0xcd4d8852(bytes32 c__0xcd4d8852) public pure {}\n\r\n  /// @dev Gives access to PanDAO Eternal Storage\r\n  address public eternalStorageAddress;\r\n  EternalStorage internal eternalStorage;\r\n\r\n  //////////////////////////////\r\n  /// @notice Modifiers\r\n  /////////////////////////////\r\n\r\n  /// @dev Ensures only Aragon Agent can call functions\r\n  modifier onlyAgent() {coverage_0xcd4d8852(0x8fd3aecb986953f53cc219fb1973b7e75f1248194aca114c438f1d1842507b46); /* function */ \n\r\ncoverage_0xcd4d8852(0xc3007cba0475a8e4c2b980e3967be641f4c52688537385beee4d2857d26a47ce); /* line */ \n    coverage_0xcd4d8852(0x1ab9770a653698385c4a72e3c42150f8f0326b762d899ba9dfb9a1b75e88f48c); /* assertPre */ \ncoverage_0xcd4d8852(0xb45623fc0787c2b2fa5d1797615961a3d146fb0b83a56b188c14731d3d6ec495); /* statement */ \nrequire(\r\n      eternalStorage.getAddress(StorageHelper.formatGet(\"dao.agent\")) == msg.sender,\r\n      \"PanDAO: UnAuthorized - Agent only\"\r\n    );coverage_0xcd4d8852(0x6a9485a936f25315b24e6731c5c4006740d08067e6933850999bdb2d8a0b029e); /* assertPost */ \n\r\ncoverage_0xcd4d8852(0x4846215bf61f35319be062f21e9d890a8197c725a65230a3762d526ae2be94a3); /* line */ \n    _;\r\n  }\r\n\r\n  /// @dev Ensures only the owning contract can call functions\r\n  modifier onlyOwner(address _owner, address _contractAddress) {coverage_0xcd4d8852(0x108fa3db25bccc83fda4f62d1b76de79987eb53a2158dcfb44851700926c116a); /* function */ \n\r\ncoverage_0xcd4d8852(0xcf9218e4603ac9246070f8421c33bac87ebf96872defe12addf2646c001f3865); /* line */ \n    coverage_0xcd4d8852(0x43db55bc882d15f77969311bc1bb4c1aa44cb820c2decd0dfdc90c5e9c2ed2b5); /* assertPre */ \ncoverage_0xcd4d8852(0x79c2c59246d9f7aef0f06ab7c7d65beec9c920b325bd2b6407a5170f90be52ad); /* statement */ \nrequire(\r\n      eternalStorage.getAddress(StorageHelper.formatAddress(\"contract.owner\", _contractAddress)) ==\r\n        _owner,\r\n      \"PanDAO: UnAuthorized - Contract owner only\"\r\n    );coverage_0xcd4d8852(0xef0319a7b5092cc61691fa5ce96ed13af3637d1e55af58f78d90d4f418ba1538); /* assertPost */ \n\r\ncoverage_0xcd4d8852(0x1af6e915613e7646faf42d966efd017286bf14971baeb9b3721a89177c3c7fcd); /* line */ \n    _;\r\n  }\r\n\r\n  //////////////////////////////\r\n  /// @notice Events\r\n  /////////////////////////////\r\n\r\n  event InsurancePoolCreated(address indexed insurancePoolAddress, string symbol);\r\n\r\n  event InsurancePoolPaused(address indexed insurancePoolAddress, string symbol);\r\n\r\n  constructor(address _eternalStorageAddress) public {coverage_0xcd4d8852(0x2365d41936e63c54320dcb6c140536b8f648ea10d299e468187f37ea32fa7350); /* function */ \n\r\ncoverage_0xcd4d8852(0xa4709adafe0b05ea7c2265952c73b053a73007c8e3a0fef1f36e06b721e98020); /* line */ \n    coverage_0xcd4d8852(0x0a6642c1e009a97b1277767da105929e781014b1aa5c55b9c4b53be435c40ded); /* statement */ \neternalStorageAddress = _eternalStorageAddress;\r\ncoverage_0xcd4d8852(0x463fe2d9f8d91a81765a210d26c2a9ebab53e8e3e7a53217456b6de6491570c2); /* line */ \n    coverage_0xcd4d8852(0x46a24c5dfcc9e0bdf4c8e278bb68709698aec0e4afae1c08a5f6f7c676287dda); /* statement */ \neternalStorage = EternalStorage(eternalStorageAddress);\r\n  }\r\n\r\n  //////////////////////////////\r\n  /// @notice Public Functions\r\n  /////////////////////////////\r\n\r\n  /// @notice Create a new PanDAO Insurance Pool\r\n  /// @dev This function can only be called by the Aragon Agent\r\n  /// @param _insuredTokenAddress address of the digital asset we want to insure\r\n  /// @param _insuredTokenSymbol string token symbol\r\n  /// @param _insureeFeeRate uint256 fee the insuree pays\r\n  /// @param _serviceFeeRate uint256 DAO fee\r\n  /// @param _premiumPeriod uint256 how often premium is pulled from the wallet insuree's wallet\r\n  function createInsurancePool(\r\n    address _insuredTokenAddress,\r\n    string memory _insuredTokenSymbol,\r\n    uint256 _insureeFeeRate,\r\n    uint256 _serviceFeeRate,\r\n    uint256 _premiumPeriod\r\n  ) public onlyAgent() {coverage_0xcd4d8852(0x8923a381a54a5780f857d563f763e7dc472aac072ab8f18488aa35714ab2a23e); /* function */ \n\r\ncoverage_0xcd4d8852(0x32b14887ec8ff55ad0b0256911e935ff2508b76382460ae79130286c66a86b4c); /* line */ \n    coverage_0xcd4d8852(0x48d5e7c6e46113c5fc1c3aa108b71d8bee73ba804fca1b0a069a552ab20910ea); /* assertPre */ \ncoverage_0xcd4d8852(0xba66040c56e3fe07753360a78384f0031ee0aba0e44775fa9a44c188f264a785); /* statement */ \nrequire(\r\n      eternalStorage.getAddress(\r\n        StorageHelper.formatAddress(\"contract.address\", _insuredTokenAddress)\r\n      ) == address(0),\r\n      \"PanDAO: Insurance Pool already exists\"\r\n    );coverage_0xcd4d8852(0xf451a21ea42abbe5f3f64b06ae2510c78201fe6bc2101bca2f1c09759e6d56fb); /* assertPost */ \n\r\n\r\ncoverage_0xcd4d8852(0xe3d3d92c49a96c7308453a841c9e0755c326e19b7bbfa93f3a66e310df0a3ba7); /* line */ \n    coverage_0xcd4d8852(0x04f2302722d6088b40ee1cad663ea75bbf2a24e5bc8bd4f508a1be9b78694c8d); /* statement */ \nInsurancePool insurancePool = new InsurancePool(\r\n      _insuredTokenAddress,\r\n      _insuredTokenSymbol,\r\n      _insureeFeeRate,\r\n      _serviceFeeRate,\r\n      _premiumPeriod,\r\n      eternalStorageAddress\r\n    );\r\n\r\ncoverage_0xcd4d8852(0x9a56e91e7e1ef9b773e947a0ccb3a1e7368848dd2b34bf567067c267a7f3b3d7); /* line */ \n    coverage_0xcd4d8852(0x771e1a0f2105074811b068124b96a0d27940a269b82758e072bdbf51387414e3); /* statement */ \nPProxyPausable proxy = new PProxyPausable();\r\ncoverage_0xcd4d8852(0xa81dce8e03573234ce07dec87d19fb4189e168f89202c61bdeb7c79afda335d0); /* line */ \n    coverage_0xcd4d8852(0xc9a3da4e485efbddd706bd80e86086a0bd50f8e0de721fe4c4b1eccaff65bc90); /* statement */ \nproxy.setImplementation(address(insurancePool));\r\ncoverage_0xcd4d8852(0x08c2014d1298b3dbd3d9ec33f46e7d7cde96e88cb58fa1ef2a678fe416492713); /* line */ \n    coverage_0xcd4d8852(0xf3f0964cce9b92b26c5eced6278e9d2a0deac9d44fb0419e3517b519b6c86975); /* statement */ \nproxy.setPauzer(address(this));\r\ncoverage_0xcd4d8852(0x89e1ae25b3e0992c40b7b6533bdc3f306fc1b8186ffc5a840b751172e6104835); /* line */ \n    coverage_0xcd4d8852(0x74a694df4fafe3f1fa45b872b4a3fb1b7843d81ddd562b98d6beb204cac374c6); /* statement */ \nproxy.setProxyOwner(address(this));\r\n\r\ncoverage_0xcd4d8852(0x409835b1dac065a21077d778c83856f3b0a98627d54e7df74ec4d059ee9b307d); /* line */ \n    coverage_0xcd4d8852(0x42f8abd3e062e4884b802991dcb0f24e6c8064cabd6596c5d737fe76a7677794); /* statement */ \nemit InsurancePoolCreated(address(insurancePool), _insuredTokenSymbol);\r\n  }\r\n\r\n  function pauseNetwork() public onlyAgent() {coverage_0xcd4d8852(0x9958114d9cb83c73529a2e3f3cdacf5d739c862e7670c79484ae9c8fb6033c3d); /* function */ \n}\r\n\r\n  function approveInsuranceClaim() public onlyAgent() {coverage_0xcd4d8852(0xc66374c49b3e49817294174c9bb45253cdb75dd111239b546c569a2b94162eaa); /* function */ \n}\r\n\r\n  function denyInsuranceClaim() public onlyAgent() {coverage_0xcd4d8852(0x44e7a9b6705aa2338a07bd4561b2a0058373c4e579a81bc5c5911681127f2933); /* function */ \n}\r\n\r\n  function updateContractImplementation() public onlyAgent() {coverage_0xcd4d8852(0xff73e3247f2f8279116747501494cc6c2522e871b9521e16232655c5532f4534); /* function */ \n}\r\n}\r\n"
    },
    "@pie-dao/proxy/contracts/PProxyPausable.sol": {
      "content": "pragma solidity ^0.6.2;\n\nimport \"./PProxy.sol\";\n\ncontract PProxyPausable is PProxy {\n\n    bytes32 constant PAUSED_SLOT = keccak256(abi.encodePacked(\"PAUSED_SLOT\"));\n    bytes32 constant PAUZER_SLOT = keccak256(abi.encodePacked(\"PAUZER_SLOT\"));\n\n    constructor() PProxy() public {\n        setAddress(PAUZER_SLOT, msg.sender);\n    }\n\n    modifier onlyPauzer() {\n        require(msg.sender == readAddress(PAUZER_SLOT), \"PProxyPausable.onlyPauzer: msg sender not pauzer\");\n        _;\n    }\n\n    modifier notPaused() {\n        require(!readBool(PAUSED_SLOT), \"PProxyPausable.notPaused: contract is paused\");\n        _;\n    }\n\n    function getPauzer() public view returns (address) {\n        return readAddress(PAUZER_SLOT);\n    }\n\n    function setPauzer(address _newPauzer) public onlyProxyOwner{\n        setAddress(PAUZER_SLOT, _newPauzer);\n    }\n\n    function renouncePauzer() public onlyPauzer {\n        setAddress(PAUZER_SLOT, address(0));\n    }\n\n    function getPaused() public view returns (bool) {\n        return readBool(PAUSED_SLOT);\n    }\n\n    function setPaused(bool _value) public onlyPauzer {\n        setBool(PAUSED_SLOT, _value);\n    }\n\n    function internalFallback() internal virtual override notPaused {\n        super.internalFallback();\n    }\n\n}"
    },
    "@pie-dao/proxy/contracts/PProxy.sol": {
      "content": "pragma solidity ^0.6.2;\n\nimport \"./PProxyStorage.sol\";\n\ncontract PProxy is PProxyStorage {\n\n    bytes32 constant IMPLEMENTATION_SLOT = keccak256(abi.encodePacked(\"IMPLEMENTATION_SLOT\"));\n    bytes32 constant OWNER_SLOT = keccak256(abi.encodePacked(\"OWNER_SLOT\"));\n\n    modifier onlyProxyOwner() {\n        require(msg.sender == readAddress(OWNER_SLOT), \"PProxy.onlyProxyOwner: msg sender not owner\");\n        _;\n    }\n\n    constructor () public {\n        setAddress(OWNER_SLOT, msg.sender);\n    }\n\n    function getProxyOwner() public view returns (address) {\n       return readAddress(OWNER_SLOT);\n    }\n\n    function setProxyOwner(address _newOwner) onlyProxyOwner public {\n        setAddress(OWNER_SLOT, _newOwner);\n    }\n\n    function getImplementation() public view returns (address) {\n        return readAddress(IMPLEMENTATION_SLOT);\n    }\n\n    function setImplementation(address _newImplementation) onlyProxyOwner public {\n        setAddress(IMPLEMENTATION_SLOT, _newImplementation);\n    }\n\n\n    fallback () external payable {\n       return internalFallback();\n    }\n\n    function internalFallback() internal virtual {\n        address contractAddr = readAddress(IMPLEMENTATION_SLOT);\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, 0, calldatasize())\n            let result := delegatecall(gas(), contractAddr, ptr, calldatasize(), 0, 0)\n            let size := returndatasize()\n            returndatacopy(ptr, 0, size)\n\n            switch result\n            case 0 { revert(ptr, size) }\n            default { return(ptr, size) }\n        }\n    }\n\n}"
    },
    "@pie-dao/proxy/contracts/PProxyStorage.sol": {
      "content": "pragma solidity ^0.6.2;\n\ncontract PProxyStorage {\n\n    function readString(bytes32 _key) public view returns(string memory) {\n        return bytes32ToString(storageRead(_key));\n    }\n\n    function setString(bytes32 _key, string memory _value) internal {\n        storageSet(_key, stringToBytes32(_value));\n    }\n\n    function readBool(bytes32 _key) public view returns(bool) {\n        return storageRead(_key) == bytes32(uint256(1));\n    }\n\n    function setBool(bytes32 _key, bool _value) internal {\n        if(_value) {\n            storageSet(_key, bytes32(uint256(1)));\n        } else {\n            storageSet(_key, bytes32(uint256(0)));\n        }\n    }\n\n    function readAddress(bytes32 _key) public view returns(address) {\n        return bytes32ToAddress(storageRead(_key));\n    }\n\n    function setAddress(bytes32 _key, address _value) internal {\n        storageSet(_key, addressToBytes32(_value));\n    }\n\n    function storageRead(bytes32 _key) public view returns(bytes32) {\n        bytes32 value;\n        //solium-disable-next-line security/no-inline-assembly\n        assembly {\n            value := sload(_key)\n        }\n        return value;\n    }\n\n    function storageSet(bytes32 _key, bytes32 _value) internal {\n        // targetAddress = _address;  // No!\n        bytes32 implAddressStorageKey = _key;\n        //solium-disable-next-line security/no-inline-assembly\n        assembly {\n            sstore(implAddressStorageKey, _value)\n        }\n    }\n\n    function bytes32ToAddress(bytes32 _value) public pure returns(address) {\n        return address(uint160(uint256(_value)));\n    }\n\n    function addressToBytes32(address _value) public pure returns(bytes32) {\n        return bytes32(uint256(_value));\n    }\n\n    function stringToBytes32(string memory _value) public pure returns (bytes32 result) {\n        bytes memory tempEmptyStringTest = bytes(_value);\n        if (tempEmptyStringTest.length == 0) {\n            return 0x0;\n        }\n\n        assembly {\n            result := mload(add(_value, 32))\n        }\n    }\n\n    function bytes32ToString(bytes32 _value) public pure returns (string memory) {\n        bytes memory bytesString = new bytes(32);\n        uint charCount = 0;\n        for (uint256 j = 0; j < 32; j++) {\n            byte char = byte(bytes32(uint(_value) * 2 ** (8 * j)));\n            if (char != 0) {\n                bytesString[charCount] = char;\n                charCount++;\n            }\n        }\n        bytes memory bytesStringTrimmed = new bytes(charCount);\n        for (uint256 j = 0; j < charCount; j++) {\n            bytesStringTrimmed[j] = bytesString[j];\n        }\n        return string(bytesStringTrimmed);\n    }\n}"
    },
    ".coverage_contracts/test/Token.sol": {
      "content": "// Solidity files have to start with this pragma.\r\n// It will be used by the Solidity compiler to validate its version.\r\npragma solidity 0.6.6;\r\n\r\n// We import this library to be able to use console.log\r\nimport \"@nomiclabs/buidler/console.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\n\r\n// This is the main building block for smart contracts.\r\ncontract Token is ERC20 {\nfunction coverage_0x71bd9d8c(bytes32 c__0x71bd9d8c) public pure {}\n\r\n  // The fixed amount of tokens stored in an unsigned integer type variable.\r\n  //prettier-ignore\r\n  // An address type variable is used to store ethereum accounts.\r\n  address public owner;\r\n\r\n  /**\r\n   * Contract initialization.\r\n   *\r\n   * The `constructor` is executed only once when the contract is created.\r\n   * The `public` modifier makes a function callable from outside the contract.\r\n   */\r\n  constructor() public ERC20(\"Test BTC++\", \"BTC++\") {coverage_0x71bd9d8c(0x9fb3324cb097e0b8e6be90d26db6d14d693f304c83049270d50dc0107ba6bffa); /* function */ \n\r\n    // The totalSupply is assigned to transaction sender, which is the account\r\n    // that is deploying the contract.\r\ncoverage_0x71bd9d8c(0x598b853d0f06e3531ee1c346336b68c213ff1b64b98cb1a8b8c0c303a69da884); /* line */ \n    coverage_0x71bd9d8c(0x364bbc4000877c1501c4d017926b3bc090c4eb1074f558a751d18386c1df9153); /* statement */ \nowner = msg.sender;\r\n\r\ncoverage_0x71bd9d8c(0x8f068b97acfe8c5282d3222d912b1b12155e849c0a79110be5804e561ee256f4); /* line */ \n    coverage_0x71bd9d8c(0xf93ee55877141ca969db7e1cfb540b4bae1537053f69723e65d16b42509dfed6); /* statement */ \n_mint(msg.sender, 100000);\r\n  }\r\n}\r\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}